{
    "contents" : "if(!exists(\"prospectTheoreticalValueGain\", mode=\"function\")) source(\"ProspectTheory.R\")\nif(!exists(\"humanRounding\", mode=\"function\")) source(\"Rounding.R\")\nif(!exists(\"probabilityWeightingGain\", mode=\"function\")) source(\"probabilityWeighting.R\")\n\nsimulateMeasuring <- function(g, G, p, x0, n, type) {\n  a <- rep(x0, n+1)\n  for (i in seq(2,n+1)) {\n    if (type == \"Gain\") {\n    pValue <- prospectTheoreticalValueGain(g, G, p, a[i-1])\n    }\n    else {\n      pValue <- prospectTheoreticalValueLoss(g, G, p, a[i-1])\n    }\n    epsilon <- pValue * 0.01\n    if (type == \"Gain\") {\n      random <- (runif(1, -epsilon, epsilon)) \n    }\n    else {\n      random <- (runif(1, epsilon, -epsilon))\n    }\n    a[i] <- pValue + random\n    a[i] <- humanRounding(a[i])\n  }\n  return(a)\n}\n\nestimateProbabilityWeightingGain <- function(p){\n  return (probabilityWeightingGain(p))\n}\n\nestimateProbabilityWeightingLoss <- function(p){\n  return (probabilityWeightingLoss(p))\n}\n\nprobabilityProportionalityGain <- function(p){\n  return ((1-estimateProbabilityWeightingGain(p))/estimateProbabilityWeightingGain(p))\n}\n\nprobabilityProportionalityLoss <- function(p){\n  return ((1-estimateProbabilityWeightingLoss(p))/estimateProbabilityWeightingLoss(p))\n}\n\n\n# Extrapolation muss implementiert werden für den Fall das b außerhalb des Experimental Sets liegt\nfindFirstElement <- function(experimentalSet,b, type){\n  if (type == \"Gain\") {\n    for (i in seq(2,length(experimentalSet))){\n      if (experimentalSet[i] > b)\n        return (i)        \n    }\n    return (-1)  \n  }\n  else {\n    for (i in seq(2,length(experimentalSet))){\n        if (experimentalSet[i] < b)\n          return (i)        \n    }\n    return (-1)\n  }\n}\n\ncalculates0 <- function(r, i, b, experimentalSet){\n  return (1/(probabilityProportionalityGain(r))) * (i-2+(b-experimentalSet[i-1])/(experimentalSet[i]-experimentalSet[i-1]))\n}\n\ncalculateStepSize <- function(s0){\n  return (1/s0)\n}\n\n# experimentalSet <- the experimental data gained from examining a person\n# normalisedPoint <- which point to use to normalise the estimated utility at (1 <= normalisedPoint <= length(experimentalSet))\n# r               <- the probability for the additional measuring required (0 <= r <= 1)\ncalculateEstimatedSet <- function(experimentalSet, normalisedPoint, r, type){\n  b <- simulateMeasuring(0,experimentalSet[1],r,experimentalSet[2],1, type)[2]\n  i <- findFirstElement(experimentalSet, b, type)\n  \n  result <- rep(NA, length(experimentalSet))\n  \n  if (type == \"Gain\") {\n    s0 <- (1/(probabilityProportionalityGain(r))) * (i-2+(b-experimentalSet[i-1])/(experimentalSet[i]-experimentalSet[i-1]))\n    for (i in seq(1, length(experimentalSet))){\n      result[i] <- ((s0+i)/(s0+normalisedPoint))\n    }\n    return (result)\n  }\n  else {\n    s0 <- (1/(probabilityProportionalityLoss(r))) * (i-2+(b-experimentalSet[i-1])/(experimentalSet[i]-experimentalSet[i-1]))  \n    for (i in seq(1, length(experimentalSet))){\n      result[i] <- (-(s0+i)/(s0+normalisedPoint))\n    }\n    return (result)\n  } \n}\n\ncalculateSlope <- function(set){\n  result <- rep (NA, length(set))\n  for (i in seq(2,length(set)))\n    result[i] <- (set[i]/set[i-1])\n  return (result)\n}",
    "created" : 1426432611608.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "349507222",
    "id" : "F2AE857E",
    "lastKnownWriteTime" : 1426443357,
    "path" : "~/GitHub/ProSeminar/ProspectTheory/TradeOffMethod.R",
    "project_path" : "TradeOffMethod.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}